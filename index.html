<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<meta name="theme-color" content="#0ea5a4" />
<meta name="description" content="Hamlet - social platform" />
<title>Hamlet</title>

<!-- Google Fonts (Arabic support included in original file) -->
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+Arabic:wght@400;500;700&display=swap" rel="stylesheet" />

<!-- Tailwind (kept as original) -->
<script src="https://cdn.tailwindcss.com"></script>

<!-- small mobile compatibility / base styles -->
<style>
  html,body,#root { height:100%; }
  body { margin:0; font-family: 'Inter', 'Noto Sans Arabic', system-ui, -apple-system, 'Segoe UI', Roboto, Arial; -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale; }
  @media (max-width:768px){ body{ -webkit-text-size-adjust:100%; } }
</style>

<!-- Preserve original importmap from AI Studio updates -->
<script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.25.0",
    "vite": "https://aistudiocdn.com/vite@^7.1.10",
    "@vitejs/plugin-react": "https://aistudiocdn.com/@vitejs/plugin-react@^5.0.4"
  }
}
</script>
</head>
<body class="bg-neutral-gray-light">
<div id="root"></div>

<!-- Keep any existing explicit env shim but make it safe and non-destructive -->
<script>
  // If a simple stub existed previously, preserve it but avoid overwriting _real_ env if set.
  window.process = window.process || {};
  window.process.env = window.process.env || {};
  // Preserve any explicit values previously put in HTML while not clobbering mapped values later
  // (example placeholders from the remote changes)
  window.process.env.VITE_USE_MOCKS = window.process.env.VITE_USE_MOCKS ?? 'true';
  window.process.env.API_KEY = window.process.env.API_KEY ?? 'your_google_gemini_api_key_here';
  window.process.env.VITE_ELECTION_DATE = window.process.env.VITE_ELECTION_DATE ?? '2025-11-11T08:00:00Z';
</script>

<!-- Vite-friendly mapping: map import.meta.env into window.process.env for libraries expecting process.env -->
<script type="module">
  (function() {
    try {
      window.process = window.process || {};
      window.process.env = window.process.env || {};
      const env = import.meta && import.meta.env ? import.meta.env : {};
      const allowed = Object.keys(env || {}).filter(k => k.startsWith('VITE_') || ['MODE','DEV','PROD','BASE_URL'].includes(k));
      for (const k of allowed) {
        // keep existing explicit window.process.env values (do not overwrite secret placeholders)
        if (window.process.env[k] === undefined) window.process.env[k] = env[k];
      }
      // convenience typed helpers
      window.getViteEnv = (name, fallback) => (window.process.env && window.process.env[name] !== undefined) ? window.process.env[name] : (env[name] !== undefined ? env[name] : fallback);

      if (import.meta.env && import.meta.env.DEV) {
        const mapped = Object.keys(window.process.env || {});
        console.info('[index.html] mapped env keys:', mapped);
      }
    } catch (e) {
      console.warn('Env mapping failed', e);
    }
  })();
</script>

<!-- Robust module boot: prefer typical Vite entry (/src/main.tsx), fallback to /index.tsx -->
<script type="module">
  (async () => {
    try {
      const tryPaths = ['/src/main.tsx', '/src/main.jsx', '/index.tsx', '/index.jsx'];
      let module;
      for (const p of tryPaths) {
        try {
          module = await import(p);
          if (module) {
            console.info('[index.html] boot module found:', p);
            break;
          }
        } catch (e) {
          // continue to next candidate
        }
      }
      if (!module) {
        throw new Error('No app entry module found. Ensure /src/main.tsx or /index.tsx exists.');
      }
      // If the module exports a default mount function, call it; otherwise assume it self-mounts.
      const maybeDefault = module && module.default;
      if (typeof maybeDefault === 'function') {
        await maybeDefault();
      } else if (typeof module.mount === 'function') {
        await module.mount();
      } else {
        // normal case: main module performs ReactDOM.createRoot(...).render(<App/>)
      }
    } catch (err) {
      console.error('[index.html] App failed to start:', err);
      const root = document.getElementById('root');
      if (root) root.innerHTML = '<div style="padding:20px;font-family:system-ui,Arial;color:#111;background:#fff;"><h2>Application failed to start</h2><pre style="white-space:pre-wrap;color:#a00;">' + (err && err.stack ? err.stack : String(err)) + '</pre></div>';
    }
  })();
</script>

<noscript>Please enable JavaScript to run this app.</noscript>
</body>
</html>